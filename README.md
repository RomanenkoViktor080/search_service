# Search service

Сервис для управления поиском пользователей с фасетной фильтрацией.

Особенности:

- Поиск поддерживает формирование фасетов для отображения фильтров. Это реализовано через агрегации.
- При поиске учитываются тарифы пользователей.
- Пользователи с **премиум-доступом** или другими (нестандартными) тарифами получают повышенный вес и чаще отображаются
  в результатах.
- Релевантность формируется с учетом **score пользователя в выборке, веса тарифа, случайного фактора**, чтобы обычные
  пользователи также имели шанс попасть в поиск.
- Для генерации случайных значений используется сид, который обновляется каждые **4 часа** (параметр можно изменить
  через свойство `hours-rotation`).

Стек:

- Язык / платформа: `Java` + `Spring Boot 3.5.4`
- Асинхронность / интеграции: `Apache Kafka`, `Avro`, `schema registry`
- Поиск: `ElasticSearch`
- БД: `PostgreSQL`, `hibernate`, `JPA` + `JDBC`, миграции - `Liquibase`;
- Утилиты: `MapStruct`, `Lombok`
- API: `REST`, `OpenAPI/Swagger`

# Подробнее о поиске:

* Пользователь делает запрос на HTTP GET `/api/v1/users/search`,
  контролер [UserController.java](src/main/java/school/faang/search_service/controller/user/UserController.java), там
  вызывается метод searchUsers в
  сервисе [UserSearchServiceImpl.java](src/main/java/school/faang/search_service/service/UserSearchServiceImpl.java)
  где формируется SearchRequest. Формируется `SearchRequest.Builder`, если есть sortCursorDto (курсор на последнего на
  загруженного странице пользователя), то пагинация через `searchAfter`; если `includeFacets = true`, то формируются
  фасеты через пагинацию, чтобы отобразить фильтры на странице и postFilter, чтобы получить отфильтрованных
  пользователй.
* Метод `buildMainQuery()` используется для полнотекстового поиска по SEARCH_FIELDS и фильтрации по активным
  пользователям
  с применением `functionScore`, чтобы учитывать тариф пользователей
    - `buildFunctions()` создает список `FunctionScore()` исходя из тарифов в бд, а также FunctionScore с random по
      _seq_no чтобы у обычных пользователй была возможность попасть в поиск. `getSeed()` используется для получения
      текущего сида, меняется каждые 4 часа, можно изменять в свойствах.
      агрегация `all_facets` - фасет с примененными всеми фильтрами. Также для каждого фасета, чей фильтр был применен (
* Метод `buildAggregations()` используется для формирования фасетов (агрегаций)
    - Логика работы:
        - Если переданы `filters` `(not null)`, всегда создаётся агрегация `all_facets` - фасет с учётом всех
          фильтров.
        - Для каждого фасета, по которому применён фильтр, формируется отдельная агрегация.  
          Например: если в фасете `color` выбран `red`, то будет создана агрегация для фасета `red`.
        - Важный момент:
            - Значения фасетов формируются через агрегацию.
            - Чтобы результаты были корректными, выборка для конкретного фасета фильтруется `по всем фильтрам, кроме
              фильтра этого фасета`.  
              Например: если выбран `color=red`, то при формировании фасета `color` данные агрегируются с учётом всех
              фильтров, кроме `color=red`. По этой же причине в buildMainQuery не фильтруем пользователей, делаем в
              postFilters
* Метод `buildFiltersQuery()` используется для создания фильтров выборки в postFilter и
  фильтрации в фасетах
* Метод `buildFilterQuery()` используется для формирования конкретного фильтра
* Метод `buildResponse()` используется для формирования ответа. Преобразует `hits в dto`, при необходимости добавляет в
  ответ фасеты
* Метод `addFacetsToResponse()` добавляет фасеты в ответ.
    - Алгоритм:
        - Метод проходит по фасетам из `all_facets`.
        - Если для конкретного фасета существует отдельная агрегация, то в ответ берётся именно она.
        - Если отдельной агрегации нет, используется значение из `all_facets`.
    - Пример:
      В `all_facets` есть фасеты: `brands`, `colors`, `sizes`.  
      При этом для `brands` была сформирована отдельная агрегация.  
      В ответ попадёт фасет `brands` из агрегации, а не из `all_facets`.  
      Для `colors` и `sizes` будут использованы данные из `all_facets`.
* Метод `sendUsersViewsEvents()` - создает события о просмотре пользователей

Другое:

* [TariffServiceImpl.java](src/main/java/school/faang/search_service/service/TariffServiceImpl.java):
    - Создание, удаление тарифов для продвижения пользователй. Используется, чтобы не делать запросы в promotion_service
    - Записи создаются через kafka евенты
* `src/main/java/school/faang/search_service/config` - расположение конфигов `kafka`, `elastic search`, `avro`,
  `swagger`
* `src/main/java/school/faang/search_service/kafka/consumer` - обработка событий на создание пользователя, изменение
  информации о пользователе, тарифа пользователя, создание и изменения тарифов
* [UserViewProducerImpl.java](src/main/java/school/faang/search_service/kafka/producer/UserViewProducerImpl.java):
  отправка события о просмотре пользователя. Используется, чтобы избежать race condition изменение счетчика и
  последующего изменения тарифа при достижении лимита (в promotion_service)
* `src/main/resources/avro/*` расположение avro схем
* [ApiExceptionHandler.java](src/main/java/school/faang/search_service/controller/ApiExceptionHandler.java):
  глобальный обработчик ошибок
